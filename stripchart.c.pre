/*---------------------------------------------------------------------------*/
/*                                                                           */
/* FILE:    stripchart.c                                                     */
/*                                                                           */
/* PURPOSE: This example illustrates the basic use of a Stripchart control.  */
/*          A timer control callback plots data to a Stripchart at regular   */
/*          intervals without direct user action.  The Stripchart control is */
/*          well-designed for continuous data display.                       */
/*                                                                           */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Include files                                                             */
/*---------------------------------------------------------------------------*/
#include <utility.h>
#include <cvirte.h>
#include <userint.h>
#include <ansi_c.h>
#include "stripchart.h"
#include "commcallback.h"
#include "mmd_comm.h"

volatile    int     LVSteamingFlag             =   0;
int ReadAdcData[32];

//static      CmtTSQHandle        tsqHdl;
//static      int                 status;
//static      CmtThreadFunctionID LVSteamThreadFunctionID;

static int hpanel;

int CVICALLBACK LVSteamThreadFunction(void *callbackData) ;
/*---------------------------------------------------------------------------*/
/* This is the application's entry-point.                                    */
/*---------------------------------------------------------------------------*/
int main (int argc, char *argv[])
{
    LVSteamingFlag             =   0;

    if (InitCVIRTE (0, argv, 0) == 0)
        return -1;
    if ((hpanel = LoadPanel (0, "stripchart.uir", PANEL)) < 0)
        return -1;

    Init_ComPort ()  ;
    /* Display the panel and run the UI */
    DisplayPanel (hpanel);
    RunUserInterface ();

    /* Free resources and return */
    ShutDownCom ()  ;
    DiscardPanel (hpanel);
    CloseCVIRTE ();
    return 0;
}


/*---------------------------------------------------------------------------*/
/* Respond to the user's choice by enabling a timer which will plot data     */
/* continuously to a Stripchart.                                             */
/*---------------------------------------------------------------------------*/
int CVICALLBACK PlotData (int panel, int control, int event,
                          void *callbackData, int eventData1, int eventData2)
{
    int val, traces, i;

    if (event == EVENT_COMMIT)
    {
        GetCtrlVal(panel, control, &val);
        // SetCtrlAttribute (panel, PANEL_TIMER, ATTR_ENABLED, val);
        LVSteamingFlag = val;
        if(val ==1)
        {
            PostDeferredCallToThread (LVSteamThreadFunction, NULL, CmtGetMainThreadID ());
        }


        GetCtrlAttribute(panel, PANEL_RESP_CHART, ATTR_NUM_TRACES, &traces);
        for (i=1; i<=traces; i++)
            SetTraceAttribute(panel, PANEL_RESP_CHART, i, ATTR_TRACE_LG_VISIBLE, 1);
		
		
		        GetCtrlAttribute(panel, PANEL_ECG_CHART, ATTR_NUM_TRACES, &traces);
        for (i=1; i<=traces; i++)
            SetTraceAttribute(panel, PANEL_ECG_CHART, i, ATTR_TRACE_LG_VISIBLE, 1);
 
		
		        GetCtrlAttribute(panel, PANEL_PPG_CHART, ATTR_NUM_TRACES, &traces);
        for (i=1; i<=traces; i++)
            SetTraceAttribute(panel, PANEL_PPG_CHART, i, ATTR_TRACE_LG_VISIBLE, 1);
 
    }
    return 0;
}

/*---------------------------------------------------------------------------*/
/* Quit the UI loop.                                                         */
/*---------------------------------------------------------------------------*/
int CVICALLBACK Shutdown (int panel, int control, int event,
                          void *callbackData, int eventData1, int eventData2)
{
    if (event == EVENT_COMMIT)
        LVSteamingFlag=0;
    QuitUserInterface (0);
    return 0;
}


/*---------------------------------------------------------------------------*/
/* Pause the stripchart traces                                               */
/*---------------------------------------------------------------------------*/
int CVICALLBACK PauseChart (int panel, int control, int event,
                            void *callbackData, int eventData1, int eventData2)
{
    int val;
    switch (event)
    {
        case EVENT_COMMIT:
            GetCtrlVal(panel, control, &val);
            SetCtrlAttribute(panel, PANEL_PPG_CHART , ATTR_STRIP_CHART_PAUSED, val);
			            SetCtrlAttribute(panel, PANEL_RESP_CHART , ATTR_STRIP_CHART_PAUSED, val);

						            SetCtrlAttribute(panel, PANEL_ECG_CHART , ATTR_STRIP_CHART_PAUSED, val);

            break;
    }
    return 0;
}



int CVICALLBACK PanelCB (int panel, int event, void *callbackData,
                         int eventData1, int eventData2)
{
    switch (event)
    {
        case EVENT_CLOSE:
            LVSteamingFlag=0;
            QuitUserInterface (0);
            break;
    }
    return 0;
}
	  /*

int CVICALLBACK LVSteamThreadFunction(void *callbackData)
{
    int traces,i;
    unsigned int opacity;
    static unsigned int oldOpacity = 255;
  double datapoints[3]; 
    double gain;

    unsigned char *ptrframe;
    unsigned char Rdbuf[64];
    unsigned char iLoopCnt = 0;
    unsigned char Wrbuf[10];
    short ADC_Data_ptr;
    //short filter_tmp;
    double fout;
    int readbytes;

    Wrbuf[0] = START_DATA_HEADER;           // Start Header
    Wrbuf[1] = DATA_STREAMING_COMMAND;      // ECG data streaming command
    Wrbuf[2] = 1;                           // Start command
    Wrbuf[3] = ADC_FUN_COMBO;
    Wrbuf[4] = END_DATA_HEADER;
    Wrbuf[5] = END_DATA_HEADER;
    Wrbuf[6] = '\n';

    readbytes = ReceiveData(Rdbuf, 7);   // Read buffer
    while (readbytes > 0)
    {
        readbytes = ReceiveData(Rdbuf, 7);
    }

    SendData(Wrbuf, 7);              // Send command to firmware
    // Stream_Live_Data = TRUE;                // Set busy flag
    // initFilter();
    //resetFilter();
    RecvInit() ;
    while( LVSteamingFlag)
    {




        memset(Rdbuf,0,63);                 // Clear receive buffer
        readbytes =ReceiveData(Rdbuf, 63);          // Read packet of 14 samples

        if(readbytes>0)
        {
            for (short i = 0; i < readbytes; i++)
            {
                ptrframe = RecvFrame(Rdbuf[i]);
                if( ptrframe)
                {
                    ADC_Data_ptr = 0;                               // Set pointer
                    ReadAdcData[ADC_Data_ptr++] = ptrframe[2];                 // Heart Rate
                    ReadAdcData[ADC_Data_ptr++] = ptrframe[3];                 // Respiration Rate

                    ReadAdcData[ADC_Data_ptr++] = ptrframe[4];                 // Lead STATUS
                    // LeadStaus = Rdbuf[4];                                   // Lead STATUS
                    for (short LC = 0; LC < 28; LC++)                       // Decode received packet of 14 samples.
                    {
                        ReadAdcData[LC+ADC_Data_ptr] =  ptrframe[LC * 2+ 6];
                        //  if (ReadAdcData[LC+ADC_Data_ptr] > 127)
                        //      ReadAdcData[LC+ADC_Data_ptr]=ReadAdcData[LC+ADC_Data_ptr] -256;
                        ReadAdcData[LC+ADC_Data_ptr] = ReadAdcData[LC+ADC_Data_ptr] << 8;
                        ReadAdcData[LC+ADC_Data_ptr] |=  ptrframe[LC * 2+ 5];              // Channel 0 ( Resp or Lead I)

                        if(LC%2 == 1)
                        {
 
                            //     datapoints[0] = 32 + gain * (( ReadAdcData[LC+ADC_Data_ptr] / 3000) - 0.5);
                            //    datapoints[1] = 96 + gain * (( ReadAdcData[LC+ADC_Data_ptr] / 3000) - 0.5);
                            //    datapoints[2] = 160 + gain * (( ReadAdcData[LC+ADC_Data_ptr] / 3000) - 0.5);
                            datapoints[0] =  ReadAdcData[LC+ADC_Data_ptr]-35900 ;
                            //  datapoints[1] =  ReadAdcData[LC+ADC_Data_ptr]-38500 ;
                            //     datapoints[2] = ReadAdcData[LC+ADC_Data_ptr]-38000 ;

                            //       datapoints[0] =  ReadAdcData[LC+ADC_Data_ptr] ;
                            // datapoints[1] =  ReadAdcData[LC+ADC_Data_ptr] ;
                            //  datapoints[2] = ReadAdcData[LC+ADC_Data_ptr] ;

                            PlotStripChart (hpanel, PANEL_ECG_CHART, datapoints, 1, 0, 0, VAL_DOUBLE);
							                            PlotStripChart (hpanel, PANEL_PPG_CHART, datapoints, 1, 0, 0, VAL_DOUBLE);

														                            PlotStripChart (hpanel, PANEL_RESP_CHART, datapoints, 1, 0, 0, VAL_DOUBLE);


                        }

                    }
                }
            }

        }
        ProcessSystemEvents();
    }

    Wrbuf[2] = 0;                                       // Stop command
    SendData(Wrbuf, 7);

    return 0;
}//DWORD WINAPI ThreadFunction(LPVOID iValue)
												*/

int CVICALLBACK LVSteamThreadFunction(void *callbackData)
{
    int traces,i;
    unsigned int opacity;
    static unsigned int oldOpacity = 255;
  double datapoints[3]; 
    double gain;

    unsigned char *ptrframe;
    unsigned char Rdbuf[64];
    unsigned char iLoopCnt = 0;
    unsigned char Wrbuf[10];
    short ADC_Data_ptr;
    //short filter_tmp;
    double fout;
    int readbytes;

    Wrbuf[0] = START_DATA_HEADER;           // Start Header
    Wrbuf[1] = DATA_STREAMING_COMMAND;      // ECG data streaming command
    Wrbuf[2] = 1;                           // Start command
    Wrbuf[3] = ADC_FUN_COMBO;
    Wrbuf[4] = END_DATA_HEADER;
    Wrbuf[5] = END_DATA_HEADER;
    Wrbuf[6] = '\n';

    readbytes = ReceiveData(Rdbuf, 7);   // Read buffer
    while (readbytes > 0)
    {
        readbytes = ReceiveData(Rdbuf, 7);
    }

    SendData(Wrbuf, 7);              // Send command to firmware
    // Stream_Live_Data = TRUE;                // Set busy flag
    // initFilter();
    //resetFilter();
    RecvInit() ;
    while( LVSteamingFlag)
    {

        memset(Rdbuf,0,63);                 // Clear receive buffer
        readbytes =ReceiveData(Rdbuf, 63);          // Read packet of 14 samples

        if(readbytes>0)
        {
            for (short i = 0; i < readbytes; i++)
            {
                ptrframe = RecvFrame(Rdbuf[i]);
                if( ptrframe)
                {
                    ADC_Data_ptr = 0;                               // Set pointer
                    ReadAdcData[ADC_Data_ptr++] = ptrframe[2];                 // Heart Rate
                    ReadAdcData[ADC_Data_ptr++] = ptrframe[3];                 // Respiration Rate

                    ReadAdcData[ADC_Data_ptr++] = ptrframe[4];                 // Lead STATUS
                    // LeadStaus = Rdbuf[4];                                   // Lead STATUS
                    for (short LC = 0; LC < PACK_SAMPLES; LC++)                       // Decode received packet of 15 samples.
                    {
                        ReadAdcData[LC+ADC_Data_ptr] =  ptrframe[LC*3 + 7];
                        //  if (ReadAdcData[LC+ADC_Data_ptr] > 127)
                        //      ReadAdcData[LC+ADC_Data_ptr]=ReadAdcData[LC+ADC_Data_ptr] -256;
                        ReadAdcData[LC+ADC_Data_ptr] = ReadAdcData[LC+ADC_Data_ptr] << 8;
                        ReadAdcData[LC+ADC_Data_ptr] |=  ptrframe[LC * 3+ 6];              // Channel 0 ( Resp or Lead I)

                       // if(LC%2 == 1)
                        {
                            /*
                                fout    =   NormalizeGhr(ReadAdcData[LC+ADC_Data_ptr], 0);

                                Filter_Noht(&fout, fout, 0);
                                Filter_Low(&fout, fout,0);
                                Filter_High(&fout, fout, 0);
                                ReadAdcData[LC+ADC_Data_ptr] = (short) fout;*/

                            //     datapoints[0] = 32 + gain * (( ReadAdcData[LC+ADC_Data_ptr] / 3000) - 0.5);
                            //    datapoints[1] = 96 + gain * (( ReadAdcData[LC+ADC_Data_ptr] / 3000) - 0.5);
                            //    datapoints[2] = 160 + gain * (( ReadAdcData[LC+ADC_Data_ptr] / 3000) - 0.5);
                            datapoints[0] =  ReadAdcData[LC+ADC_Data_ptr]-35900 ;
                            //  datapoints[1] =  ReadAdcData[LC+ADC_Data_ptr]-38500 ;
                            //     datapoints[2] = ReadAdcData[LC+ADC_Data_ptr]-38000 ;

                            //       datapoints[0] =  ReadAdcData[LC+ADC_Data_ptr] ;
                            // datapoints[1] =  ReadAdcData[LC+ADC_Data_ptr] ;
                            //  datapoints[2] = ReadAdcData[LC+ADC_Data_ptr] ;

                            /* Note how we plot three points at once, one for each trace */
							if(ptrframe[LC*3 + 5] ==SAMPLE_ECG)
                            PlotStripChart (hpanel, PANEL_ECG_CHART, datapoints, 1, 0, 0, VAL_DOUBLE);
							if(ptrframe[LC*3 + 5]==SAMPLE_PPG)  
							    PlotStripChart (hpanel, PANEL_PPG_CHART, datapoints, 1, 0, 0, VAL_DOUBLE);
							if(ptrframe[LC*3 + 5]==SAMPLE_RESP)  
								PlotStripChart (hpanel, PANEL_RESP_CHART, datapoints, 1, 0, 0, VAL_DOUBLE);


                        }

                    }
                }
            }

        }
        ProcessSystemEvents();
    }

    Wrbuf[2] = 0;                                       // Stop command
    SendData(Wrbuf, 7);

    return 0;
}//DWORD WINAPI ThreadFunction(LPVOID iValue)
